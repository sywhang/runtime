// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace System.Diagnostics.Tracing
{

    public class Keywords
    {
        public const EventKeywords GCKeyword = (EventKeywords)0x1;
        public const EventKeywords GCHandleKeyword = (EventKeywords)0x2;
        public const EventKeywords AssemblyLoaderKeyword = (EventKeywords)0x4;
        public const EventKeywords LoaderKeyword = (EventKeywords)0x8;
        public const EventKeywords JitKeyword = (EventKeywords)0x10;
        public const EventKeywords NGenKeyword = (EventKeywords)0x20;
        public const EventKeywords StartEnumerationKeyword = (EventKeywords)0x40;
        public const EventKeywords EndEnumerationKeyword = (EventKeywords)0x80;
        public const EventKeywords SecurityKeyword = (EventKeywords)0x400;
        public const EventKeywords AppDomainResourceManagementKeyword = (EventKeywords)0x800;
        public const EventKeywords JitTracingKeyword = (EventKeywords)0x1000;
        public const EventKeywords InteropKeyword = (EventKeywords)0x2000;
        public const EventKeywords ContentionKeyword = (EventKeywords)0x4000;
        public const EventKeywords ExceptionKeyword = (EventKeywords)0x8000;
        public const EventKeywords ThreadingKeyword = (EventKeywords)0x10000;
        public const EventKeywords JittedMethodILToNativeMapKeyword = (EventKeywords)0x20000;
        public const EventKeywords OverrideAndSuppressNGenEventsKeyword = (EventKeywords)0x40000;
        public const EventKeywords TypeKeyword = (EventKeywords)0x80000;
        public const EventKeywords GCHeapDumpKeyword = (EventKeywords)0x100000;
        public const EventKeywords GCSampledObjectAllocationHighKeyword = (EventKeywords)0x200000;
        public const EventKeywords GCHeapSurvivalAndMovementKeyword = (EventKeywords)0x400000;
        public const EventKeywords GCHeapCollectKeyword = (EventKeywords)0x800000;
        public const EventKeywords GCHeapAndTypeNamesKeyword = (EventKeywords)0x1000000;
        public const EventKeywords GCSampledObjectAllocationLowKeyword = (EventKeywords)0x2000000;
        public const EventKeywords PerfTrackKeyword = (EventKeywords)0x20000000;
        public const EventKeywords StackKeyword = (EventKeywords)0x40000000;
        public const EventKeywords ThreadTransferKeyword = (EventKeywords)0x80000000;
        public const EventKeywords DebuggerKeyword = (EventKeywords)0x100000000;
        public const EventKeywords MonitoringKeyword = (EventKeywords)0x200000000;
        public const EventKeywords CodeSymbolsKeyword = (EventKeywords)0x400000000;
        public const EventKeywords EventSourceKeyword = (EventKeywords)0x800000000;
        public const EventKeywords CompilationKeyword = (EventKeywords)0x1000000000;
        public const EventKeywords CompilationDiagnosticKeyword = (EventKeywords)0x2000000000;
        public const EventKeywords MethodDiagnosticKeyword = (EventKeywords)0x4000000000;
        public const EventKeywords TypeDiagnosticKeyword = (EventKeywords)0x8000000000;
        public const EventKeywords JitInstrumentationDataKeyword = (EventKeywords)0x10000000000;
    }


    /// <summary>
    /// NativeRuntimeEventSource is an EventSource that represents the ETW/EventPipe events emitted by the native runtime.
    /// Most of NativeRuntimeEventSource is auto-generated by scripts/genRuntimeEventSources.py based on the contents of the
    /// Microsoft-Windows-DotNETRuntime provider and will throw a NotImplementedException without hand-written overloads of the Events.
    /// To have a runtime event be fired from the managed code, you need to add a managed definition for that event
    /// and call into the native runtime that invoke the appropriate native sinks for the platform (i.e. ETW, EventPipe, LTTng).
    /// To see some examples of this, refer to NativeRuntimeEventSource.PortableThreadPool.CoreClr.cs and NativeRuntimeEventSource.PortableThreadPool.cs.
    /// Then, modify genRuntimeEventSources.py to skip over the event so that it doesn't generate the dummy method.
    /// </summary>
    [EventSource(Guid = "E13C0D23-CCBC-4E12-931B-D9CC2EEE27E4", Name = EventSourceName)]
    [EventSourceAutoGenerate]
    internal sealed partial class NativeRuntimeEventSource : EventSource
    {
        internal const string EventSourceName = "Microsoft-Windows-DotNETRuntime";
        public static readonly NativeRuntimeEventSource Log = new NativeRuntimeEventSource();

        // Parameterized constructor to block initialization and ensure the EventSourceGenerator is creating the default constructor
        // as you can't make a constructor partial.
        private NativeRuntimeEventSource(int _) { }

        /// <summary>
        /// Dispatch a single event with the specified event ID and payload.
        /// </summary>
        /// <param name="eventID">The eventID corresponding to the event as defined in the auto-generated portion of the NativeRuntimeEventSource class.</param>
        /// <param name="osThreadID">The thread ID of the operating system thread.</param>
        /// <param name="timeStamp">The current timestamp.</param>
        /// <param name="activityId">The ID of the current activity.</param>
        /// <param name="childActivityId">The ID of the current child activity.</param>
        /// <param name="payload">A span pointing to the data payload for the event.</param>
        [NonEvent]
        internal unsafe void ProcessEvent(uint eventID, uint osThreadID, DateTime timeStamp, Guid activityId, Guid childActivityId, ReadOnlySpan<byte> payload)
        {
            // A simple fix to avoid dependencies brought by this method if event source is disabled via a feature switch.
            // Should be reconsidered when https://github.com/dotnet/runtime/issues/43657 is done.
            if (!IsSupported)
            {
                return;
            }

            // Make sure the eventID is valid.
            if (eventID >= m_eventData!.Length)
            {
                return;
            }

            // Decode the payload.
            object[] decodedPayloadFields = EventPipePayloadDecoder.DecodePayload(ref m_eventData[eventID], payload);
            WriteToAllListeners(
                eventId: (int)eventID,
                osThreadId: &osThreadID,
                timeStamp: &timeStamp,
                activityID: &activityId,
                childActivityID: &childActivityId,
                args: decodedPayloadFields);
        }

        [Event(1, Version = 2, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword)]
        private void GCStart_V2(uint Count, uint Depth, uint Reason, uint Type, ushort ClrInstanceID, ulong ClientSequenceNumber)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(2, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword)]
        private void GCEnd_V1(uint Count, uint Depth, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(3, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword)]
        private void GCRestartEEEnd_V1(ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(4, Version = 2, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword)]
        private void GCHeapStats_V2(ulong GenerationSize0, ulong TotalPromotedSize0, ulong GenerationSize1, ulong TotalPromotedSize1, ulong GenerationSize2, ulong TotalPromotedSize2, ulong GenerationSize3, ulong TotalPromotedSize3, ulong FinalizationPromotedSize, ulong FinalizationPromotedCount, uint PinnedObjectCount, uint SinkBlockCount, uint GCHandleCount, ushort ClrInstanceID, ulong GenerationSize4, ulong TotalPromotedSize4)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(5, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword)]
        private void GCCreateSegment_V1(ulong Address, ulong Size, uint Type, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(6, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword)]
        private void GCFreeSegment_V1(ulong Address, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(7, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword)]
        private void GCRestartEEBegin_V1(ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(8, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword)]
        private void GCSuspendEEEnd_V1(ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(9, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword)]
        private void GCSuspendEEBegin_V1(uint Reason, uint Count, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(10, Version = 3, Level = EventLevel.Verbose, Keywords = Keywords.GCKeyword)]
        private void GCAllocationTick_V3(uint AllocationAmount, uint AllocationKind, ushort ClrInstanceID, ulong AllocationAmount64, IntPtr TypeID, string TypeName, uint HeapIndex, IntPtr Address)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(11, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword | Keywords.ThreadingKeyword)]
        private void GCCreateConcurrentThread_V1(ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(12, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword | Keywords.ThreadingKeyword)]
        private void GCTerminateConcurrentThread_V1(ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(13, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword)]
        private void GCFinalizersEnd_V1(uint Count, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(14, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword)]
        private void GCFinalizersBegin_V1(ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(15, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.TypeKeyword)]
        private void BulkType(uint Count, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(16, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCHeapDumpKeyword)]
        private void GCBulkRootEdge(uint Index, uint Count, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(17, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCHeapDumpKeyword)]
        private void GCBulkRootConditionalWeakTableElementEdge(uint Index, uint Count, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(18, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCHeapDumpKeyword)]
        private void GCBulkNode(uint Index, uint Count, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(19, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCHeapDumpKeyword)]
        private void GCBulkEdge(uint Index, uint Count, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(20, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCSampledObjectAllocationHighKeyword)]
        private void GCSampledObjectAllocationHigh(IntPtr Address, IntPtr TypeID, uint ObjectCountForTypeSample, ulong TotalSizeForTypeSample, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(21, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCHeapSurvivalAndMovementKeyword)]
        private void GCBulkSurvivingObjectRanges(uint Index, uint Count, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(22, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCHeapSurvivalAndMovementKeyword)]
        private void GCBulkMovedObjectRanges(uint Index, uint Count, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(23, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCHeapSurvivalAndMovementKeyword)]
        private void GCGenerationRange(byte Generation, IntPtr RangeStart, ulong RangeUsedLength, ulong RangeReservedLength, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(25, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword)]
        private void GCMarkStackRoots(uint HeapNum, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(26, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword)]
        private void GCMarkFinalizeQueueRoots(uint HeapNum, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(27, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword)]
        private void GCMarkHandles(uint HeapNum, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(28, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword)]
        private void GCMarkOlderGenerationRoots(uint HeapNum, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(29, Version = 0, Level = EventLevel.Verbose, Keywords = Keywords.GCKeyword)]
        private void FinalizeObject(IntPtr TypeID, IntPtr ObjectID, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(30, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCHandleKeyword)]
        private void SetGCHandle(IntPtr HandleID, IntPtr ObjectID, uint Kind, uint Generation, ulong AppDomainID, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(31, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCHandleKeyword)]
        private void DestroyGCHandle(IntPtr HandleID, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(32, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCSampledObjectAllocationLowKeyword)]
        private void GCSampledObjectAllocationLow(IntPtr Address, IntPtr TypeID, uint ObjectCountForTypeSample, ulong TotalSizeForTypeSample, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(33, Version = 0, Level = EventLevel.Verbose, Keywords = Keywords.GCKeyword)]
        private void PinObjectAtGCTime(IntPtr HandleID, IntPtr ObjectID, ulong ObjectSize, string TypeName, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(35, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword)]
        private void GCTriggered(uint Reason, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(36, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCHeapDumpKeyword)]
        private void GCBulkRootCCW(uint Count, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(37, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCHeapDumpKeyword)]
        private void GCBulkRCW(uint Count, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(38, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCHeapDumpKeyword)]
        private void GCBulkRootStaticVar(uint Count, ulong AppDomainID, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(39, Version = 0, Level = EventLevel.LogAlways, Keywords = Keywords.GCKeyword | Keywords.GCHandleKeyword | Keywords.GCHeapDumpKeyword | Keywords.GCSampledObjectAllocationHighKeyword | Keywords.GCHeapSurvivalAndMovementKeyword | Keywords.GCHeapCollectKeyword | Keywords.GCHeapAndTypeNamesKeyword | Keywords.GCSampledObjectAllocationLowKeyword)]
        private void GCDynamicEvent(string Name, uint DataSize)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(40, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.ThreadingKeyword)]
        private void WorkerThreadCreate(uint WorkerThreadCount, uint RetiredWorkerThreads)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(41, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.ThreadingKeyword)]
        private void WorkerThreadTerminate(uint WorkerThreadCount, uint RetiredWorkerThreads)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(42, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.ThreadingKeyword)]
        private void WorkerThreadRetire(uint WorkerThreadCount, uint RetiredWorkerThreads)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(43, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.ThreadingKeyword)]
        private void WorkerThreadUnretire(uint WorkerThreadCount, uint RetiredWorkerThreads)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(44, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.ThreadingKeyword)]
        private void IOThreadCreate_V1(uint IOThreadCount, uint RetiredIOThreads, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(45, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.ThreadingKeyword)]
        private void IOThreadTerminate_V1(uint IOThreadCount, uint RetiredIOThreads, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(46, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.ThreadingKeyword)]
        private void IOThreadRetire_V1(uint IOThreadCount, uint RetiredIOThreads, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(47, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.ThreadingKeyword)]
        private void IOThreadUnretire_V1(uint IOThreadCount, uint RetiredIOThreads, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(48, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.ThreadingKeyword)]
        private void ThreadpoolSuspensionSuspendThread(uint ClrThreadID, uint CpuUtilization)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(49, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.ThreadingKeyword)]
        private void ThreadpoolSuspensionResumeThread(uint ClrThreadID, uint CpuUtilization)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(70, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.ThreadingKeyword | Keywords.ThreadTransferKeyword)]
        private void ThreadCreating(IntPtr ID, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(71, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.ThreadingKeyword | Keywords.ThreadTransferKeyword)]
        private void ThreadRunning(IntPtr ID, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(72, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.MethodDiagnosticKeyword)]
        private void MethodDetails(ulong MethodID, ulong TypeID, uint MethodToken, uint TypeParameterCount, ulong LoaderModuleID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(73, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.TypeDiagnosticKeyword)]
        private void TypeLoadStart(uint TypeLoadStartID, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(74, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.TypeDiagnosticKeyword)]
        private void TypeLoadStop(uint TypeLoadStartID, ushort ClrInstanceID, ushort LoadLevel, ulong TypeID, string TypeName)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(80, Version = 1, Level = EventLevel.Error, Keywords = Keywords.ExceptionKeyword | Keywords.MonitoringKeyword)]
        private void ExceptionThrown_V1(string ExceptionType, string ExceptionMessage, IntPtr ExceptionEIP, uint ExceptionHRESULT, ushort ExceptionFlags, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(250, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.ExceptionKeyword)]
        private void ExceptionCatchStart(ulong EntryEIP, ulong MethodID, string MethodName, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(251, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.ExceptionKeyword)]
        private void ExceptionCatchStop()
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(252, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.ExceptionKeyword)]
        private void ExceptionFinallyStart(ulong EntryEIP, ulong MethodID, string MethodName, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(253, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.ExceptionKeyword)]
        private void ExceptionFinallyStop()
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(254, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.ExceptionKeyword)]
        private void ExceptionFilterStart(ulong EntryEIP, ulong MethodID, string MethodName, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(255, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.ExceptionKeyword)]
        private void ExceptionFilterStop()
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(256, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.ExceptionKeyword)]
        private void ExceptionThrownStop()
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(81, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.ContentionKeyword)]
        private void ContentionStart_V1(byte ContentionFlags, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(91, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.ContentionKeyword)]
        private void ContentionStop_V1(byte ContentionFlags, ushort ClrInstanceID, double DurationNs)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(82, Version = 0, Level = EventLevel.LogAlways, Keywords = Keywords.StackKeyword)]
        private void CLRStackWalk(ushort ClrInstanceID, byte Reserved1, byte Reserved2, uint FrameCount)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(83, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.AppDomainResourceManagementKeyword)]
        private void AppDomainMemAllocated(ulong AppDomainID, ulong Allocated, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(84, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.AppDomainResourceManagementKeyword)]
        private void AppDomainMemSurvived(ulong AppDomainID, ulong Survived, ulong ProcessSurvived, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(85, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.AppDomainResourceManagementKeyword | Keywords.ThreadingKeyword)]
        private void ThreadCreated(ulong ManagedThreadID, ulong AppDomainID, uint Flags, uint ManagedThreadIndex, uint OSThreadID, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(86, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.AppDomainResourceManagementKeyword | Keywords.ThreadingKeyword)]
        private void ThreadTerminated(ulong ManagedThreadID, ulong AppDomainID, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(87, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.AppDomainResourceManagementKeyword | Keywords.ThreadingKeyword)]
        private void ThreadDomainEnter(ulong ManagedThreadID, ulong AppDomainID, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(88, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.InteropKeyword)]
        private void ILStubGenerated(ushort ClrInstanceID, ulong ModuleID, ulong StubMethodID, uint StubFlags, uint ManagedInteropMethodToken, string ManagedInteropMethodNamespace, string ManagedInteropMethodName, string ManagedInteropMethodSignature, string NativeMethodSignature, string StubMethodSignature, string StubMethodILCode)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(89, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.InteropKeyword)]
        private void ILStubCacheHit(ushort ClrInstanceID, ulong ModuleID, ulong StubMethodID, uint ManagedInteropMethodToken, string ManagedInteropMethodNamespace, string ManagedInteropMethodName, string ManagedInteropMethodSignature)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(135, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.JitKeyword | Keywords.NGenKeyword)]
        private void DCStartCompleteV2()
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(136, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.JitKeyword | Keywords.NGenKeyword)]
        private void DCEndCompleteV2()
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(137, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.JitKeyword | Keywords.NGenKeyword)]
        private void MethodDCStartV2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, uint MethodSize, uint MethodToken, uint MethodFlags)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(138, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.JitKeyword | Keywords.NGenKeyword)]
        private void MethodDCEndV2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, uint MethodSize, uint MethodToken, uint MethodFlags)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(139, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.JitKeyword | Keywords.NGenKeyword)]
        private void MethodDCStartVerboseV2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, uint MethodSize, uint MethodToken, uint MethodFlags, string MethodNamespace, string MethodName, string MethodSignature)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(140, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.JitKeyword | Keywords.NGenKeyword)]
        private void MethodDCEndVerboseV2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, uint MethodSize, uint MethodToken, uint MethodFlags, string MethodNamespace, string MethodName, string MethodSignature)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(141, Version = 2, Level = EventLevel.Informational, Keywords = Keywords.JitKeyword | Keywords.NGenKeyword)]
        private void MethodLoad_V2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, uint MethodSize, uint MethodToken, uint MethodFlags, ushort ClrInstanceID, ulong ReJITID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(159, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.CompilationDiagnosticKeyword)]
        private void R2RGetEntryPoint(ulong MethodID, string MethodNamespace, string MethodName, string MethodSignature, ulong EntryPoint, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(160, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.CompilationDiagnosticKeyword)]
        private void R2RGetEntryPointStart(ulong MethodID, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(142, Version = 2, Level = EventLevel.Informational, Keywords = Keywords.JitKeyword | Keywords.NGenKeyword)]
        private void MethodUnload_V2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, uint MethodSize, uint MethodToken, uint MethodFlags, ushort ClrInstanceID, ulong ReJITID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(143, Version = 2, Level = EventLevel.Informational, Keywords = Keywords.JitKeyword | Keywords.NGenKeyword)]
        private void MethodLoadVerbose_V2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, uint MethodSize, uint MethodToken, uint MethodFlags, string MethodNamespace, string MethodName, string MethodSignature, ushort ClrInstanceID, ulong ReJITID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(144, Version = 2, Level = EventLevel.Informational, Keywords = Keywords.JitKeyword | Keywords.NGenKeyword)]
        private void MethodUnloadVerbose_V2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, uint MethodSize, uint MethodToken, uint MethodFlags, string MethodNamespace, string MethodName, string MethodSignature, ushort ClrInstanceID, ulong ReJITID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(145, Version = 1, Level = EventLevel.Verbose, Keywords = Keywords.JitKeyword)]
        private void MethodJittingStarted_V1(ulong MethodID, ulong ModuleID, uint MethodToken, uint MethodILSize, string MethodNamespace, string MethodName, string MethodSignature, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(146, Version = 0, Level = EventLevel.Verbose, Keywords = Keywords.JitKeyword)]
        private void MethodJitMemoryAllocatedForCode(ulong MethodID, ulong ModuleID, ulong JitHotCodeRequestSize, ulong JitRODataRequestSize, ulong AllocatedSizeForJitCode, uint JitAllocFlag, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(185, Version = 0, Level = EventLevel.Verbose, Keywords = Keywords.JitTracingKeyword)]
        private void MethodJitInliningSucceeded(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string InlinerNamespace, string InlinerName, string InlinerNameSignature, string InlineeNamespace, string InlineeName, string InlineeNameSignature, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(186, Version = 0, Level = EventLevel.Verbose, Keywords = Keywords.JitTracingKeyword)]
        private void MethodJitInliningFailedAnsi(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string InlinerNamespace, string InlinerName, string InlinerNameSignature, string InlineeNamespace, string InlineeName, string InlineeNameSignature, bool FailAlways)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(188, Version = 0, Level = EventLevel.Verbose, Keywords = Keywords.JitTracingKeyword)]
        private void MethodJitTailCallSucceeded(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string CallerNamespace, string CallerName, string CallerNameSignature, string CalleeNamespace, string CalleeName, string CalleeNameSignature, bool TailPrefix, uint TailCallType, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(189, Version = 0, Level = EventLevel.Verbose, Keywords = Keywords.JitTracingKeyword)]
        private void MethodJitTailCallFailedAnsi(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string CallerNamespace, string CallerName, string CallerNameSignature, string CalleeNamespace, string CalleeName, string CalleeNameSignature, bool TailPrefix)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(190, Version = 0, Level = EventLevel.Verbose, Keywords = Keywords.JittedMethodILToNativeMapKeyword)]
        private void MethodILToNativeMap(ulong MethodID, ulong ReJITID, byte MethodExtent, ushort CountOfMapEntries)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(191, Version = 0, Level = EventLevel.Verbose, Keywords = Keywords.JitTracingKeyword)]
        private void MethodJitTailCallFailed(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string CallerNamespace, string CallerName, string CallerNameSignature, string CalleeNamespace, string CalleeName, string CalleeNameSignature, bool TailPrefix, string FailReason, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(192, Version = 0, Level = EventLevel.Verbose, Keywords = Keywords.JitTracingKeyword)]
        private void MethodJitInliningFailed(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string InlinerNamespace, string InlinerName, string InlinerNameSignature, string InlineeNamespace, string InlineeName, string InlineeNameSignature, bool FailAlways, string FailReason, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(149, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.LoaderKeyword)]
        private void ModuleDCStartV2(ulong ModuleID, ulong AssemblyID, uint ModuleFlags, uint Reserved1, string ModuleILPath, string ModuleNativePath)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(150, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.LoaderKeyword)]
        private void ModuleDCEndV2(ulong ModuleID, ulong AssemblyID, uint ModuleFlags, uint Reserved1, string ModuleILPath, string ModuleNativePath)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(151, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.LoaderKeyword)]
        private void DomainModuleLoad_V1(ulong ModuleID, ulong AssemblyID, ulong AppDomainID, uint ModuleFlags, uint Reserved1, string ModuleILPath, string ModuleNativePath, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(152, Version = 2, Level = EventLevel.Informational, Keywords = Keywords.LoaderKeyword | Keywords.PerfTrackKeyword)]
        private void ModuleLoad_V2(ulong ModuleID, ulong AssemblyID, uint ModuleFlags, uint Reserved1, string ModuleILPath, string ModuleNativePath, ushort ClrInstanceID, Guid ManagedPdbSignature, uint ManagedPdbAge, string ManagedPdbBuildPath, Guid NativePdbSignature, uint NativePdbAge, string NativePdbBuildPath)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(153, Version = 2, Level = EventLevel.Informational, Keywords = Keywords.LoaderKeyword | Keywords.PerfTrackKeyword)]
        private void ModuleUnload_V2(ulong ModuleID, ulong AssemblyID, uint ModuleFlags, uint Reserved1, string ModuleILPath, string ModuleNativePath, ushort ClrInstanceID, Guid ManagedPdbSignature, uint ManagedPdbAge, string ManagedPdbBuildPath, Guid NativePdbSignature, uint NativePdbAge, string NativePdbBuildPath)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(154, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.LoaderKeyword)]
        private void AssemblyLoad_V1(ulong AssemblyID, ulong AppDomainID, ulong BindingID, uint AssemblyFlags, string FullyQualifiedAssemblyName, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(155, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.LoaderKeyword)]
        private void AssemblyUnload_V1(ulong AssemblyID, ulong AppDomainID, ulong BindingID, uint AssemblyFlags, string FullyQualifiedAssemblyName, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(156, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.LoaderKeyword)]
        private void AppDomainLoad_V1(ulong AppDomainID, uint AppDomainFlags, string AppDomainName, uint AppDomainIndex, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(157, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.LoaderKeyword)]
        private void AppDomainUnload_V1(ulong AppDomainID, uint AppDomainFlags, string AppDomainName, uint AppDomainIndex, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(158, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.PerfTrackKeyword)]
        private void ModuleRangeLoad(ushort ClrInstanceID, ulong ModuleID, uint RangeBegin, uint RangeSize, byte RangeType)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(181, Version = 1, Level = EventLevel.Verbose, Keywords = Keywords.SecurityKeyword)]
        private void StrongNameVerificationStart_V1(uint VerificationFlags, uint ErrorCode, string FullyQualifiedAssemblyName, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(182, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.SecurityKeyword)]
        private void StrongNameVerificationStop_V1(uint VerificationFlags, uint ErrorCode, string FullyQualifiedAssemblyName, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(183, Version = 1, Level = EventLevel.Verbose, Keywords = Keywords.SecurityKeyword)]
        private void AuthenticodeVerificationStart_V1(uint VerificationFlags, uint ErrorCode, string ModulePath, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(184, Version = 1, Level = EventLevel.Informational, Keywords = Keywords.SecurityKeyword)]
        private void AuthenticodeVerificationStop_V1(uint VerificationFlags, uint ErrorCode, string ModulePath, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(187, Version = 0, Level = EventLevel.Informational)]
        private void RuntimeInformationStart(ushort ClrInstanceID, ushort Sku, ushort BclMajorVersion, ushort BclMinorVersion, ushort BclBuildNumber, ushort BclQfeNumber, ushort VMMajorVersion, ushort VMMinorVersion, ushort VMBuildNumber, ushort VMQfeNumber, uint StartupFlags, byte StartupMode, string CommandLine, Guid ComObjectGuid, string RuntimeDllPath)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(200, Version = 0, Level = EventLevel.Verbose, Keywords = Keywords.GCKeyword)]
        private void IncreaseMemoryPressure(ulong BytesAllocated, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(201, Version = 0, Level = EventLevel.Verbose, Keywords = Keywords.GCKeyword)]
        private void DecreaseMemoryPressure(ulong BytesFreed, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(202, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword)]
        private void GCMarkWithType(uint HeapNum, ushort ClrInstanceID, uint Type, ulong Bytes)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(203, Version = 2, Level = EventLevel.Verbose, Keywords = Keywords.GCKeyword)]
        private void GCJoin_V2(uint Heap, uint JoinTime, uint JoinType, ushort ClrInstanceID, uint JoinID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(204, Version = 3, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword)]
        private void GCPerHeapHistory_V3(ushort ClrInstanceID, IntPtr FreeListAllocated, IntPtr FreeListRejected, IntPtr EndOfSegAllocated, IntPtr CondemnedAllocated, IntPtr PinnedAllocated, IntPtr PinnedAllocatedAdvance, uint RunningFreeListEfficiency, uint CondemnReasons0, uint CondemnReasons1, uint CompactMechanisms, uint ExpandMechanisms, uint HeapIndex, IntPtr ExtraGen0Commit, uint Count)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(205, Version = 3, Level = EventLevel.Informational, Keywords = Keywords.GCKeyword)]
        private void GCGlobalHeapHistory_V3(ulong FinalYoungestDesired, int NumHeaps, uint CondemnedGeneration, uint Gen0ReductionCount, uint Reason, uint GlobalMechanisms, ushort ClrInstanceID, uint PauseMode, uint MemoryPressure, uint CondemnReasons0, uint CondemnReasons1)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(206, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCHeapDumpKeyword)]
        private void GenAwareBegin(uint Count, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(207, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.GCHeapDumpKeyword)]
        private void GenAwareEnd(uint Count, ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(240, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.DebuggerKeyword)]
        private void DebugIPCEventStart()
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(241, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.DebuggerKeyword)]
        private void DebugIPCEventEnd()
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(242, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.DebuggerKeyword)]
        private void DebugExceptionProcessingStart()
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(243, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.DebuggerKeyword)]
        private void DebugExceptionProcessingEnd()
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(260, Version = 0, Level = EventLevel.Verbose, Keywords = Keywords.CodeSymbolsKeyword)]
        private void CodeSymbols(ulong ModuleId, ushort TotalChunks, ushort ChunkNumber, uint ChunkLength)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(270, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.EventSourceKeyword)]
        private void EventSource(int EventID, string EventName, string EventSourceName, string Payload)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(280, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.CompilationKeyword)]
        private void TieredCompilationSettings(ushort ClrInstanceID, uint Flags)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(281, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.CompilationKeyword)]
        private void TieredCompilationPause(ushort ClrInstanceID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(282, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.CompilationKeyword)]
        private void TieredCompilationResume(ushort ClrInstanceID, uint NewMethodCount)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(283, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.CompilationKeyword)]
        private void TieredCompilationBackgroundJitStart(ushort ClrInstanceID, uint PendingMethodCount)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(284, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.CompilationKeyword)]
        private void TieredCompilationBackgroundJitStop(ushort ClrInstanceID, uint PendingMethodCount, uint JittedMethodCount)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(290, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.AssemblyLoaderKeyword)]
        private void AssemblyLoadStart(ushort ClrInstanceID, string AssemblyName, string AssemblyPath, string RequestingAssembly, string AssemblyLoadContext, string RequestingAssemblyLoadContext)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(291, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.AssemblyLoaderKeyword)]
        private void AssemblyLoadStop(ushort ClrInstanceID, string AssemblyName, string AssemblyPath, string RequestingAssembly, string AssemblyLoadContext, string RequestingAssemblyLoadContext, bool Success, string ResultAssemblyName, string ResultAssemblyPath, bool Cached)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(292, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.AssemblyLoaderKeyword)]
        private void ResolutionAttempted(ushort ClrInstanceID, string AssemblyName, ushort Stage, string AssemblyLoadContext, ushort Result, string ResultAssemblyName, string ResultAssemblyPath, string ErrorMessage)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(293, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.AssemblyLoaderKeyword)]
        private void AssemblyLoadContextResolvingHandlerInvoked(ushort ClrInstanceID, string AssemblyName, string HandlerName, string AssemblyLoadContext, string ResultAssemblyName, string ResultAssemblyPath)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(294, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.AssemblyLoaderKeyword)]
        private void AppDomainAssemblyResolveHandlerInvoked(ushort ClrInstanceID, string AssemblyName, string HandlerName, string ResultAssemblyName, string ResultAssemblyPath)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(295, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.AssemblyLoaderKeyword)]
        private void AssemblyLoadFromResolveHandlerInvoked(ushort ClrInstanceID, string AssemblyName, bool IsTrackedLoad, string RequestingAssemblyPath, string ComputedRequestedAssemblyPath)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(296, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.AssemblyLoaderKeyword)]
        private void KnownPathProbed(ushort ClrInstanceID, string FilePath, ushort Source, int Result)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(297, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.JitInstrumentationDataKeyword)]
        private void JitInstrumentationData(ushort ClrInstanceID, uint MethodFlags, uint DataSize, ulong MethodID)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

        [Event(298, Version = 0, Level = EventLevel.Informational, Keywords = Keywords.JitInstrumentationDataKeyword)]
        private void JitInstrumentationDataVerbose(ushort ClrInstanceID, uint MethodFlags, uint DataSize, ulong MethodID, ulong ModuleID, uint MethodToken, string MethodNamespace, string MethodName, string MethodSignature)
        {
            // To have this event be emitted from managed side, refer to NativeRuntimeEventSource.cs
            throw new NotImplementedException();
        }

    }
}
